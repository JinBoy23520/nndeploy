# 视频播放速度修复说明

## 🐛 问题描述

**用户反馈**: SideBySideCompare 和 VideoPlayer 节点播放速度过快，希望与原视频速度一致。

## 🔍 问题原因

所有显示节点都没有正确的帧率控制：
1. **VideoPlayer**: 虽然有 `fps_=30` 参数，但没有从视频源自动检测实际 FPS
2. **SideBySideCompare**: 完全没有帧率控制，只有 `cv2.waitKey(1)` (1毫秒延迟)
3. **DetailZoomCompare**: 同样没有帧率控制

这导致视频以最快速度播放（取决于 CPU 处理速度），而不是原视频的实际帧率。

---

## ✅ 解决方案

为三个显示节点添加**自动 FPS 检测**功能，从 OpenCvVideoDecode 节点获取源视频的实际帧率。

### 修改文件

1. ✅ [video_player.py](python/nndeploy/codec/video_player.py)
2. ✅ [side_by_side_compare.py](python/nndeploy/codec/side_by_side_compare.py)
3. ✅ [detail_zoom_compare.py](python/nndeploy/codec/detail_zoom_compare.py)

---

## 🔧 技术实现

### 1. 添加新参数

```python
self.fps_ = 30  # 默认 FPS，可被自动检测覆盖
self.auto_fps_ = True  # 是否自动检测视频 FPS
self.fps_detected_ = False  # FPS 是否已检测
self.last_frame_time = time.time()  # 上一帧时间戳
```

### 2. 自动 FPS 检测（run 方法开始）

```python
# 自动检测视频 FPS（首次运行）
if self.auto_fps_ and not self.fps_detected_:
    try:
        # 从 OpenCvVideoDecode 节点获取 FPS
        input_node = input_edge.producer_
        if hasattr(input_node, 'cap_') and input_node.cap_ is not None:
            detected_fps = input_node.cap_.get(cv2.CAP_PROP_FPS)
            if detected_fps > 0:
                self.fps_ = detected_fps
                print(f"✓ 自动检测到视频 FPS: {self.fps_:.2f}")
            self.fps_detected_ = True
    except Exception as e:
        print(f"⚠ 无法自动检测 FPS，使用默认值: {self.fps_}")
        self.fps_detected_ = True
```

### 3. 帧率控制（run 方法结尾）

```python
# 帧率控制 - 根据目标 FPS 延迟
if self.fps_ > 0:
    target_delay = 1.0 / self.fps_  # 每帧应该的时间间隔
    elapsed_frame = time.time() - self.last_frame_time
    sleep_time = target_delay - elapsed_frame
    if sleep_time > 0:
        time.sleep(sleep_time)  # 精确延迟
    self.last_frame_time = time.time()
```

### 4. 更新序列化/反序列化

```python
def serialize(self):
    # ...
    json_obj["fps_"] = self.fps_
    json_obj["auto_fps_"] = self.auto_fps_
    # ...

def deserialize(self, target: str):
    # ...
    self.fps_ = json_obj.get("fps_", 30)
    self.auto_fps_ = json_obj.get("auto_fps_", True)
    # ...
```

---

## 📊 工作原理

### 自动检测流程

```
┌─────────────────┐
│ OpenCvVideoDecode│
│  cap_.get(FPS)  │  ← 从视频文件读取实际FPS
└────────┬────────┘
         │ 自动检测
         ↓
┌─────────────────┐
│   显示节点        │
│  fps_ = 25.0    │  ← 自动设置为源视频FPS
└────────┬────────┘
         │ 帧率控制
         ↓
   time.sleep()       ← 精确控制播放速度
```

### 帧率控制逻辑

```
目标延迟 = 1.0 / FPS  （例如 25 FPS → 0.04秒/帧）
实际延迟 = 当前时间 - 上一帧时间
需要休眠 = 目标延迟 - 实际延迟

如果需要休眠 > 0，则 time.sleep(需要休眠)
```

---

## 🎯 使用示例

### 自动检测（默认行为）

```json
{
  "name_": "VideoPlayer",
  "auto_fps_": true,
  "fps_": 30
}
```

- 首次运行时自动检测视频 FPS
- 如果检测到 25 FPS，则以 25 FPS 播放
- 如果检测失败，使用默认 30 FPS

### 手动设置 FPS

```json
{
  "name_": "VideoPlayer",
  "auto_fps_": false,
  "fps_": 24
}
```

- 禁用自动检测
- 强制使用 24 FPS 播放

### 快速播放（测试用）

```json
{
  "name_": "VideoPlayer",
  "auto_fps_": false,
  "fps_": 0
}
```

- `fps_: 0` 表示不进行帧率控制
- 以最快速度播放（处理速度）

---

## 🔍 验证方法

### 1. 查看控制台输出

启动服务后，应该看到：

```
✓ 自动检测到视频 FPS: 25.00
```

或

```
✓ SideBySideCompare 自动检测到视频 FPS: 30.00
✓ DetailZoomCompare 自动检测到视频 FPS: 30.00
```

### 2. 观察显示的 FPS

窗口左上角显示的 FPS 应该接近源视频的 FPS：

```
FPS: 25.1  ← 应该稳定在源视频FPS附近
```

### 3. 测试不同视频

```python
# 测试 25 FPS 视频
resources/videos/test_25fps.mp4  → 显示 "FPS: 25.0"

# 测试 30 FPS 视频
resources/videos/test_30fps.mp4  → 显示 "FPS: 30.0"

# 测试 60 FPS 视频
resources/videos/test_60fps.mp4  → 显示 "FPS: 60.0"
```

---

## ⚠️ 注意事项

### 1. OpenCvVideoDecode 节点要求

自动检测依赖于 `OpenCvVideoDecode` 节点的 `cap_` 属性：

```python
if hasattr(input_node, 'cap_') and input_node.cap_ is not None:
    detected_fps = input_node.cap_.get(cv2.CAP_PROP_FPS)
```

如果使用其他视频解码节点，可能无法自动检测。

### 2. 检测失败的情况

如果遇到以下情况，会使用默认 30 FPS：

- 视频文件损坏
- 视频文件没有 FPS 元数据
- 使用了不兼容的解码节点
- 网络流（部分格式）

### 3. 性能影响

- 超分处理速度慢于源 FPS 时，会自然变慢
- `time.sleep()` 精度受操作系统限制（通常 1-15ms）
- 高 FPS 视频（60+）可能有轻微抖动

---

## 🆕 更新的参数

### VideoPlayer

| 参数 | 类型 | 默认值 | 说明 |
|-----|------|--------|------|
| `fps_` | float | 30 | 目标播放帧率 |
| `auto_fps_` | bool | true | 是否自动检测源视频FPS |
| `show_fps_` | bool | true | 是否显示FPS信息 |

### SideBySideCompare

| 参数 | 类型 | 默认值 | 说明 |
|-----|------|--------|------|
| `fps_` | float | 30 | 目标播放帧率 |
| `auto_fps_` | bool | true | 是否自动检测源视频FPS |
| `show_fps_` | bool | true | 是否显示FPS信息 |
| `original_size_` | bool | false | 是否显示原始尺寸 |

### DetailZoomCompare

| 参数 | 类型 | 默认值 | 说明 |
|-----|------|--------|------|
| `fps_` | float | 30 | 目标播放帧率 |
| `auto_fps_` | bool | true | 是否自动检测源视频FPS |
| `show_fps_` | bool | true | 是否显示FPS信息 |
| `zoom_factor_` | int | 4 | 局部放大倍数 |

---

## 🎉 修复后的效果

### 修复前
- ❌ 视频播放速度过快（60-100+ FPS）
- ❌ 无法控制播放速度
- ❌ 不同视频都以相同速度播放

### 修复后
- ✅ 自动匹配源视频 FPS（25/30/60 FPS）
- ✅ 播放速度与原视频一致
- ✅ 可手动设置 FPS 或禁用自动检测
- ✅ 实时显示当前 FPS

---

## 🔄 兼容性

- ✅ **向后兼容**: 旧工作流无需修改，自动使用 `auto_fps_=true`
- ✅ **跨平台**: Windows / macOS / Linux 均支持
- ✅ **多格式**: 支持 MP4, AVI, MKV 等常见视频格式

---

## 📝 后续改进

可以考虑的改进方向：

1. **更精确的时间控制**: 使用高精度计时器替代 `time.sleep()`
2. **动态 FPS 调整**: 根据处理能力动态调整目标 FPS
3. **帧缓冲**: 添加帧缓冲队列，平滑播放
4. **音频同步**: 如果包含音频，同步音视频播放

---

**修复日期**: 2026年1月10日  
**影响范围**: 所有使用 VideoPlayer, SideBySideCompare, DetailZoomCompare 的工作流  
**需要操作**: 重启服务即可自动生效，无需修改工作流配置
